# Docker Compose pour Raspberry Pi 4 - Production
# Architecture: Bot Worker + Dashboard + Redis + SQLite (Standalone)
#
# Utilisation:
#   ./scripts/deploy_prod.sh
#   (ou docker compose -f docker-compose.prod.yml up -d)

services:
  # ========================================
  # REDIS (Queue pour Bot Worker)
  # ========================================
  redis-bot:
    image: redis:7-alpine
    container_name: redis-bot
    env_file: .env
    volumes:
    - redis-bot-data:/data
    # Optimisations Redis pour Pi 4 (AOF only)
    command: >
      redis-server
      --appendonly yes
      --appendfsync everysec
      --no-appendfsync-on-rewrite yes
      --maxmemory 256mb
      --maxmemory-policy allkeys-lru
      --loglevel warning
    sysctls:
      - net.core.somaxconn=511
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 300M
        reservations:
          cpus: '0.25'
          memory: 200M
    logging:
      driver: json-file
      options:
        max-size: 5m
        max-file: '2'
        compress: 'true'
    restart: unless-stopped
    healthcheck:
      test: [CMD, redis-cli, ping]
      interval: 30s
      timeout: 5s
      retries: 3
    networks:
    - linkedin-network

  # ========================================
  # REDIS (Cache pour Dashboard)
  # ========================================
  redis-dashboard:
    image: redis:7-alpine
    container_name: redis-dashboard
    env_file: .env
    # Cache only (no persistence)
    command: >
      redis-server
      --maxmemory 64mb
      --maxmemory-policy allkeys-lru
      --save ""
      --appendonly no
      --loglevel warning
    sysctls:
      - net.core.somaxconn=511
    restart: unless-stopped
    volumes:
    - redis-dashboard-data:/data
    deploy:
      resources:
        limits:
          memory: 100M
          cpus: '0.5'
        reservations:
          memory: 50M
          cpus: '0.25'
    logging:
      driver: json-file
      options:
        max-size: 5m
        max-file: '2'
        compress: 'true'
    healthcheck:
      test: [CMD, redis-cli, ping]
      interval: 30s
      timeout: 5s
      retries: 3
    networks:
    - linkedin-network

  # ========================================
  # API (Pont entre Dashboard et Worker)
  # ========================================
  api:
    image: ghcr.io/gaspardd78/linkedin-birthday-auto-bot:latest
    container_name: bot-api
    command: uvicorn src.api.app:app --host 0.0.0.0 --port 8000
    env_file: .env
    privileged: true
    environment:
    - REDIS_HOST=redis-bot
    - REDIS_PORT=6379
    - PYTHONPATH=/app
    - LOG_LEVEL=INFO
    - DATABASE_URL=sqlite:///app/data/linkedin.db
    - API_KEY=${API_KEY:?API_KEY must be set in .env file}
    - ENABLE_TELEMETRY=false
    - SERVICE_NAME=api
    - LINKEDIN_BOT_CONFIG_PATH=/app/config/config.yaml
    volumes:
    - ./logs:/app/logs
    - ./config:/app/config
    - shared-data:/app/data
    - /run/systemd:/run/systemd:ro
    - /var/run/dbus:/var/run/dbus:ro
    - /bin/systemctl:/bin/systemctl:ro
    deploy:
      resources:
        limits:
          cpus: '0.5'
          memory: 500M
        reservations:
          memory: 200M
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "python", "-c", "import urllib.request; print(urllib.request.urlopen('http://localhost:8000/health').read())"]
      interval: 30s
      timeout: 10s
      retries: 5
      start_period: 90s
    networks:
    - linkedin-network

  # ========================================
  # BOT WORKER (RQ Worker avec Playwright)
  # ========================================
  bot-worker:
    image: ghcr.io/gaspardd78/linkedin-birthday-auto-bot:latest
    container_name: bot-worker
    command: python -m src.queue.worker
    env_file: .env
    depends_on:
      redis-bot:
        condition: service_healthy
    environment:
    - REDIS_HOST=redis-bot
    - REDIS_PORT=6379
    - PYTHONPATH=/app
    - LOG_LEVEL=INFO
    - DATABASE_URL=sqlite:///app/data/linkedin.db
    - ENABLE_TELEMETRY=false
    - SERVICE_NAME=worker
    - LINKEDIN_BOT_CONFIG_PATH=/app/config/config.yaml
    volumes:
    - ./logs:/app/logs
    - ./config:/app/config
    - shared-data:/app/data
    deploy:
      resources:
        limits:
          cpus: '1.5'
          memory: 1800M
        reservations:
          cpus: '0.5'
          memory: 512M
    logging:
      driver: json-file
      options:
        max-size: 5m
        max-file: '2'
        compress: 'true'
    restart: unless-stopped
    healthcheck:
      test: [CMD, python, -c, "import redis; r = redis.Redis(host='redis-bot', port=6379); r.ping()"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 120s
    networks:
    - linkedin-network

  # ========================================
  # DASHBOARD (Next.js avec SQLite)
  # ========================================
  dashboard:
    image: ghcr.io/gaspardd78/linkedin-birthday-auto-dashboard:latest
    pull_policy: always
    restart: unless-stopped
    container_name: dashboard
    env_file: .env
    ports:
    - ${DASHBOARD_PORT:-3000}:3000
    deploy:
      resources:
        limits:
          memory: 400M
          cpus: '1.0'
        reservations:
          memory: 200M
          cpus: '0.25'
    logging:
      driver: json-file
      options:
        max-size: 5m
        max-file: '2'
        compress: 'true'
    environment:
    - NODE_ENV=production
    - NEXT_TELEMETRY_DISABLED=1
    - DATABASE_URL=sqlite:///app/data/linkedin.db
    - REDIS_URL=redis://redis-dashboard:6379
    - BOT_API_URL=http://api:8000
    - BOT_API_KEY=${API_KEY:?API_KEY must be set in .env file}
    - JWT_SECRET=${JWT_SECRET}
    - DASHBOARD_USER=${DASHBOARD_USER}
    - DASHBOARD_PASSWORD=${DASHBOARD_PASSWORD}
    - SERVICE_NAME=dashboard
    volumes:
    - ./logs:/app/logs
    - ./config:/app/config
    - shared-data:/app/data
    - /sys/class/thermal:/sys/class/thermal:ro
    depends_on:
      redis-dashboard:
        condition: service_healthy
      api:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "node", "-e", "fetch('http://localhost:3000/api/system/health').then(r => {if(!r.ok) process.exit(1)})"]
      interval: 60s
      timeout: 10s
      retries: 3
      start_period: 30s
    networks:
    - linkedin-network

volumes:
  redis-bot-data:
    name: linkedin-bot-redis-data
  redis-dashboard-data:
    name: linkedin-dashboard-redis-data
  shared-data:
    name: linkedin-shared-data

networks:
  linkedin-network:
    name: linkedin-network
    driver: bridge
